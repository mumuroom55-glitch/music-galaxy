<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Celestial Fluid Breath - Enhanced</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        
        /* 启动遮罩 - 更深邃的背景 */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            background: radial-gradient(circle at center, #0a0a14 0%, #000000 100%);
            z-index: 10; flex-direction: column; transition: opacity 1.5s ease-out;
        }
        h1 { color: #fff; font-weight: 100; letter-spacing: 15px; text-shadow: 0 0 60px rgba(180,230,255,0.8), 0 0 20px rgba(100,150,255,0.4); margin-bottom: 40px; opacity: 0.95; font-size: 2.5em; text-align: center; }
        
        /* 按钮风格 */
        label.upload-btn {
            background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255,255,255,0.15);
            color: #ddd; padding: 16px 60px; cursor: pointer; border-radius: 50px;
            font-size: 12px; letter-spacing: 4px; transition: 0.6s cubic-bezier(0.16, 1, 0.3, 1);
            backdrop-filter: blur(10px); text-transform: uppercase;
        }
        label.upload-btn:hover { background: rgba(255, 255, 255, 0.15); color: white; box-shadow: 0 0 50px rgba(100,200,255,0.4), inset 0 0 20px rgba(100,200,255,0.2); border-color: rgba(255,255,255,0.3); transform: scale(1.02); }
        input[type="file"] { display: none; }

        /* 顶部形状切换栏 */
        #shape-controls {
            position: absolute; top: 40px; left: 50%; transform: translateX(-50%);
            z-index: 5; display: flex; gap: 25px;
            opacity: 0; transition: opacity 1.5s; pointer-events: none;
            background: rgba(0,0,0,0.3); padding: 10px 20px; border-radius: 30px;
            backdrop-filter: blur(5px); border: 1px solid rgba(255,255,255,0.05);
        }
        #shape-controls.visible { opacity: 1; pointer-events: auto; }
        
        .shape-btn {
            background: transparent; border: none; color: #777;
            padding: 8px 12px; cursor: pointer; font-size: 11px; transition: 0.4s; letter-spacing: 2px;
            position: relative; font-weight: 300;
        }
        .shape-btn::after {
            content: ''; position: absolute; bottom: 0; left: 50%; width: 0; height: 1px; 
            background: linear-gradient(90deg, transparent, #fff, transparent); transition: 0.4s cubic-bezier(0.16, 1, 0.3, 1); transform: translateX(-50%); opacity: 0.5;
        }
        .shape-btn:hover { color: #bbb; }
        .shape-btn.active { color: #fff; text-shadow: 0 0 15px rgba(255,255,255,0.6); }
        .shape-btn.active::after { width: 80%; opacity: 1; }

        /* 左下角播放器 */
        #player-ui {
            position: absolute; bottom: 50px; left: 50px; width: 300px;
            z-index: 5; display: flex; flex-direction: column; gap: 15px;
            opacity: 0; transition: opacity 1.5s, transform 1.5s; transform: translateY(30px);
        }
        #player-ui.visible { opacity: 1; transform: translateY(0); }

        .track-info { display: flex; justify-content: space-between; color: rgba(255,255,255,0.7); font-size: 10px; letter-spacing: 2px; text-transform: uppercase; }
        
        .controls-row { display: flex; align-items: center; gap: 20px; margin-top: 5px; }
        
        #play-pause-btn {
            width: 40px; height: 40px; border-radius: 50%; border: 1px solid rgba(255,255,255,0.1);
            background: rgba(255,255,255,0.02); color: #fff; cursor: pointer;
            display: flex; justify-content: center; align-items: center; font-size: 12px; transition: 0.4s;
            backdrop-filter: blur(4px);
        }
        #play-pause-btn:hover { background: rgba(255,255,255,0.1); border-color: rgba(255,255,255,0.3); box-shadow: 0 0 20px rgba(255,255,255,0.1); }

        /* 细长的进度条 */
        input[type=range] {
            -webkit-appearance: none; width: 100%; background: transparent; cursor: pointer;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 1px; background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0.3));
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 8px; width: 8px; border-radius: 50%;
            background: #fff; margin-top: -3.5px; box-shadow: 0 0 15px rgba(255,255,255,0.8); opacity: 0; transition: 0.3s;
        }
        #player-ui:hover input[type=range]::-webkit-slider-thumb { opacity: 1; }
        
    </style>
</head>
<body>

    <div id="overlay">
        <h1>CELESTIAL BREATH</h1>
        <label class="upload-btn" for="musicUpload">Enter the Void</label>
        <input type="file" id="musicUpload" accept="audio/*">
    </div>

    <div id="shape-controls">
        <button class="shape-btn active" onclick="switchShape('galaxy')">GALAXY</button>
        <button class="shape-btn" onclick="switchShape('heart')">VOLUMETRIC HEART</button>
        <button class="shape-btn" onclick="switchShape('sphere')">NEBULA SPHERE</button>
        <button class="shape-btn" onclick="switchShape('mobius')">MOBIUS FLOW</button>
    </div>

    <div id="player-ui">
        <div class="track-info">
            <span style="font-weight: 300; opacity: 0.6;">Interactive Engine</span>
            <span id="time-display" style="font-family: monospace; opacity: 0.6;">0:00</span>
        </div>
        <input type="range" id="progress-bar" value="0" step="0.1">
        <div class="controls-row">
            <button id="play-pause-btn">❚❚</button>
            <span style="font-size: 9px; color: rgba(255,255,255,0.3); letter-spacing: 1px;">MOUSE REPULSION: ACTIVE</span>
        </div>
    </div>

    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float size;
        attribute vec3 customColor;
        attribute vec3 targetPosition;

        uniform float uTime;
        uniform float uAudioLevel;
        uniform float uAudioHigh;
        uniform vec2 uMouse;
        uniform vec2 uResolution;
        uniform float uTransitionProgress;
        
        varying vec3 vColor;
        varying float vDistance;

        // 伪随机函数
        float random (vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);
        }

        void main() {
            vColor = customColor;

            // 1. 基础形状插值 (Lerp between current pos and target pos)
            vec3 mixedPos = mix(position, targetPosition, uTransitionProgress);

            // 2. 复杂的呼吸运动 (多重波形叠加，轻重缓急)
            // 基础缓慢呼吸
            float breathBase = sin(uTime * 0.6) * 0.04;
            // 随音频低频的剧烈起伏
            float breathAudio = sin(uTime * 2.5 + mixedPos.x * 0.01) * uAudioLevel * 0.15;
            // 高频颤动
            float tremble = sin(uTime * 8.0 + mixedPos.y * 0.02) * uAudioHigh * 0.02;
            
            float totalBreathScale = 1.0 + breathBase + breathAudio + tremble;

            vec3 finalPos = mixedPos * totalBreathScale;

            // 3. 音频涟漪波 (Ripple)
            float distFromCenter = length(finalPos);
            vDistance = distFromCenter; // 传递给片元着色器用于可能的颜色调整
            
            float rippleWave = sin(distFromCenter * 0.015 - uTime * 3.0);
            vec3 rippleDir = normalize(finalPos);
            // 涟漪强度随音频增强
            float rippleStrength = 4.0 + uAudioLevel * 25.0;
            finalPos += rippleDir * rippleWave * rippleStrength;
            
            // 4. 鼠标排斥 (Mouse Repulsion) - Screen Space Approximation
            // 将鼠标坐标转换为大概的世界坐标范围 (假设相机Z在400左右)
            vec3 mouseWorldPos = vec3((uMouse.x * 2.0 - 1.0) * 400.0 * (uResolution.x/uResolution.y), (uMouse.y * 2.0 - 1.0) * 400.0, 0.0);
            
            // 计算粒子在XY平面上距离鼠标投影点的距离
            float mouseDist = distance(finalPos.xy, mouseWorldPos.xy);
            float repulsionRadius = 180.0; // 排斥半径
            
            if (mouseDist < repulsionRadius) {
                float force = (1.0 - mouseDist / repulsionRadius); // 距离越近力越大
                force = pow(force, 2.0) * 120.0; // 指数级增强力场
                vec2 dir = normalize(finalPos.xy - mouseWorldPos.xy);
                finalPos.xy += dir * force;
                // 稍微向Z轴推一点，增加立体感
                finalPos.z -= force * 0.5;
            }

            vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
            
            // 大小随距离衰减，并受呼吸影响
            gl_PointSize = size * (400.0 / -mvPosition.z) * totalBreathScale;
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform vec3 color;
        uniform sampler2D pointTexture;
        uniform float uAudioLevel;

        varying vec3 vColor;
        varying float vDistance;

        void main() {
            // 圆形裁剪
            vec2 cxy = 2.0 * gl_PointCoord - 1.0;
            float r = dot(cxy, cxy);
            if (r > 1.0) discard;

            // 基础纹理
            vec4 tex = texture2D(pointTexture, gl_PointCoord);
            
            // 动态颜色调整：中心更亮白，外部更深邃
            vec3 finalColor = vColor;
            // 随音乐强度增加亮度
            finalColor += vec3(uAudioLevel * 0.3); 
            
            // 距离中心越近，越接近核心颜色（偏金/白）
            float distFactor = smoothstep(0.0, 500.0, vDistance);
            finalColor = mix(finalColor + vec3(0.2, 0.2, 0.1), finalColor * vec3(0.8, 0.9, 1.0), distFactor);

            // Alpha 边缘柔化
            float alpha = (1.0 - r) * (0.6 + uAudioLevel * 0.4); // 音乐越强越不透明

            gl_FragColor = vec4(color * finalColor, alpha) * tex;
        }
    </script>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // 显著增加粒子数量以获得更丰富、更细腻的效果
        const PARTICLE_COUNT = 100000; 
        
        let camera, scene, renderer, composer, controls;
        let particleSystem, uniforms, geometry;
        let analyser, dataArray, audioContext, audioEl;
        let currentShape = 'galaxy';
        let isPlaying = false;
        let startTime = Date.now();
        let mouse = new THREE.Vector2(0.5, 0.5);
        
        // 形状数据
        const shapes = {
            sphere: new Float32Array(PARTICLE_COUNT * 3),
            galaxy: new Float32Array(PARTICLE_COUNT * 3),
            heart: new Float32Array(PARTICLE_COUNT * 3),
            mobius: new Float32Array(PARTICLE_COUNT * 3)
        };
        
        // 用于形状切换的过渡变量
        let transitionTarget = 'galaxy';
        let transitionProgress = 1.0; // 0 = old shape, 1 = new shape

        const rand = (min, max) => Math.random() * (max - min) + min;
        const randNormal = () => (Math.random() + Math.random() + Math.random() + Math.random() - 2.0) / 2.0; // 更集中的正态分布近似

        const playBtn = document.getElementById('play-pause-btn');
        const progressBar = document.getElementById('progress-bar');
        const timeDisplay = document.getElementById('time-display');

        init();
        calculateAllShapes(); // 预计算所有形状
        animate();

        function init() {
            scene = new THREE.Scene();
            // 极深邃的背景色
            scene.fog = new THREE.FogExp2(0x000000, 0.0015);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 5000);
            camera.position.set(0, 0, 550);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance", stencil: false, depth: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 限制像素比以保证性能
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.5; // 提高曝光度增强光感
            document.body.appendChild(renderer.domElement);

            // 增加鼠标控制以便观察
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.3;
            controls.enablePan = false;
            controls.maxDistance = 1200;
            controls.minDistance = 200;

            // 后期处理：极强的辉光
            const renderScene = new THREE.RenderPass(scene, camera);
            // 参数调整：更高强度，更大半径，更低阈值
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 2.5, 0.6, 0.3);
            bloomPass.threshold = 0.15; 
            bloomPass.strength = 2.8; 
            bloomPass.radius = 1.1;

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            createParticleSystem();

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousemove', onMouseMove);
            document.getElementById('musicUpload').addEventListener('change', handleAudioUpload);
            playBtn.addEventListener('click', togglePlay);
            progressBar.addEventListener('input', handleProgressInput);
        }

        function onMouseMove(event) {
            // 归一化鼠标坐标 (0.0 - 1.0)
            mouse.x = event.clientX / window.innerWidth;
            mouse.y = 1.0 - (event.clientY / window.innerHeight); // Flip Y
        }

        function createParticleSystem() {
            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);
            const sizes = new Float32Array(PARTICLE_COUNT);

            const colorObj = new THREE.Color();

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                // 初始位置归零
                positions[i3] = positions[i3+1] = positions[i3+2] = 0;
                targetPositions[i3] = targetPositions[i3+1] = targetPositions[i3+2] = 0;

                // 丰富的色彩生成逻辑
                // 基于索引的随机分布，创造色彩层次
                let hueType = Math.random();
                let hue, saturation, lightness;
                
                if (hueType < 0.1) { 
                    // 核心亮色 (金/白)
                    hue = rand(0.05, 0.12); saturation = rand(0.8, 1.0); lightness = rand(0.7, 0.95);
                    sizes[i] = rand(3.0, 6.0); // 核心粒子更大
                } else if (hueType < 0.5) { 
                    // 主体蓝色系 (青/蓝)
                    hue = rand(0.55, 0.65); saturation = rand(0.7, 0.9); lightness = rand(0.4, 0.7);
                    sizes[i] = rand(1.5, 3.5);
                } else if (hueType < 0.8) { 
                    // 边缘紫色系 (紫/粉)
                    hue = rand(0.7, 0.85); saturation = rand(0.6, 0.9); lightness = rand(0.3, 0.6);
                    sizes[i] = rand(1.0, 2.5);
                } else {
                    // 背景深空色
                    hue = rand(0.6, 0.7); saturation = rand(0.3, 0.5); lightness = rand(0.1, 0.3);
                    sizes[i] = rand(0.5, 1.5);
                }

                colorObj.setHSL(hue, saturation, lightness);
                colors[i3] = colorObj.r;
                colors[i3+1] = colorObj.g;
                colors[i3+2] = colorObj.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            // targetPosition 用于 Shader 中的插值
            geometry.setAttribute('targetPosition', new THREE.BufferAttribute(targetPositions, 3)); 
            geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            // Shader Material 定义
            uniforms = {
                uTime: { value: 0.0 },
                uAudioLevel: { value: 0.0 }, // 低频音量
                uAudioHigh: { value: 0.0 },  // 高频音量
                uMouse: { value: new THREE.Vector2(0.5, 0.5) },
                uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                uTransitionProgress: { value: 1.0 },
                pointTexture: { value: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png') },
                color: { value: new THREE.Color(0xffffff) }
            };

            const material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true,
                vertexColors: true
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        function calculateAllShapes() {
             // 1. Rich Galaxy (更丰富、更立体的银河)
             const galaxy = shapes.galaxy;
             for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                // 核心更密集
                const radius = Math.pow(Math.random(), 1.5) * 350; 
                const spinAngle = radius * 0.015;
                const branchAngle = (i % 5) * ((Math.PI * 2) / 5); // 5条旋臂
                
                const randomOffset = () => randNormal() * (20 + radius * 0.1);

                galaxy[i3] = Math.cos(branchAngle + spinAngle) * radius + randomOffset();
                galaxy[i3+1] = Math.sin(branchAngle + spinAngle) * radius + randomOffset();
                // 垂直分布，中心厚，边缘薄
                galaxy[i3+2] = randNormal() * (60 * (1 - radius/350) + 10) + randNormal() * 20; 
            }

            // 2. Volumetric Heart (立体心形)
            const heart = shapes.heart;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                 const i3 = i * 3;
                 let t = rand(0, Math.PI * 2);
                 // 关键：增加一个体积累积因子，让粒子填充内部
                 // Math.pow(Math.random(), 0.3) 使得外部更密集，内部也有填充
                 let volumeScale = Math.pow(Math.random(), 0.3) * 12; 
                 
                 let x = 16 * Math.pow(Math.sin(t), 3);
                 let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                 // Z轴给予厚度
                 let z = randNormal() * 6;

                 heart[i3] = x * volumeScale;
                 heart[i3+1] = y * volumeScale + 50; // 稍微向上偏移
                 heart[i3+2] = z * volumeScale;
            }

            // 3. Nebula Sphere (星云球体 - 表面+内部)
            const sphere = shapes.sphere;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const radius = 220 * Math.pow(Math.random(), 0.2); // 体积填充
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                sphere[i3] = radius * Math.sin(phi) * Math.cos(theta);
                sphere[i3+1] = radius * Math.sin(phi) * Math.sin(theta);
                sphere[i3+2] = radius * Math.cos(phi);
            }

             // 4. Volumetric Mobius (立体莫比乌斯环)
             const mobius = shapes.mobius;
             for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                let u = rand(0, Math.PI * 2);
                let v = rand(-1, 1);
                // 增加厚度随机性
                let thickness = randNormal() * 15;
                let radius = 160;
                let stripWidth = 70;
                
                let x = (radius + v * stripWidth/2 * Math.cos(u/2)) * Math.cos(u);
                let y = (radius + v * stripWidth/2 * Math.cos(u/2)) * Math.sin(u);
                let z = v * stripWidth/2 * Math.sin(u/2) + thickness;

                mobius[i3] = x; mobius[i3+1] = y; mobius[i3+2] = z;
            }

            // 初始设置
            geometry.attributes.position.array.set(shapes[currentShape]);
            geometry.attributes.targetPosition.array.set(shapes[currentShape]);
            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.targetPosition.needsUpdate = true;
        }

        function handleAudioUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            if (audioEl) audioEl.pause();
            if (audioContext) audioContext.close();

            audioEl = document.createElement('audio');
            audioEl.src = URL.createObjectURL(file);
            audioEl.loop = false;
            
            audioEl.addEventListener('canplay', () => {
                if(!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const src = audioContext.createMediaElementSource(audioEl);
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 2048;
                    analyser.smoothingTimeConstant = 0.88; // 稍微降低平滑度以提高响应速度
                    src.connect(analyser);
                    analyser.connect(audioContext.destination);
                    dataArray = new Uint8Array(analyser.frequencyBinCount);
                }
                playMusic();
            });

            audioEl.addEventListener('timeupdate', updateProgress);
            audioEl.addEventListener('ended', () => { isPlaying = false; playBtn.innerHTML = '►'; });

            document.getElementById('overlay').style.opacity = 0;
            setTimeout(() => {
                document.getElementById('overlay').style.display = 'none';
                document.getElementById('shape-controls').classList.add('visible');
                document.getElementById('player-ui').classList.add('visible');
            }, 1500);
        }

        function playMusic() {
            audioContext.resume().then(() => { audioEl.play(); isPlaying = true; playBtn.innerHTML = '❚❚'; });
        }
        function togglePlay() {
            if (!audioEl) return;
            if (isPlaying) { audioEl.pause(); playBtn.innerHTML = '►'; } 
            else { audioEl.play(); playBtn.innerHTML = '❚❚'; }
            isPlaying = !isPlaying;
        }
        function updateProgress() {
            if (audioEl && audioEl.duration) {
                progressBar.value = (audioEl.currentTime / audioEl.duration) * 100;
                timeDisplay.textContent = formatTime(audioEl.currentTime);
            }
        }
        function handleProgressInput() {
             if(audioEl) audioEl.currentTime = (progressBar.value / 100) * audioEl.duration;
        }
        function formatTime(s) {
            const m = Math.floor(s / 60);
            const sec = Math.floor(s % 60);
            return `${m}:${sec < 10 ? '0' : ''}${sec}`;
        }
        
        window.switchShape = function(name) {
            if (name === currentShape) return;
            
            // 将当前位置固化到 position attribute
            // 这样着色器就可以从当前状态插值到新的 targetPosition
            const currentPositions = geometry.attributes.position.array;
            const targetPositionsAttr = geometry.attributes.targetPosition.array;

            // 简单的深拷贝，实际应用中可能需要在Shader中处理更复杂的过渡
            // 这里为了简化，直接更新 targetPosition 并重置进度
            // 更完美的做法是使用两个 target buffer 进行 ping-pong
            geometry.attributes.targetPosition.array.set(shapes[name]);
            geometry.attributes.targetPosition.needsUpdate = true;

            currentShape = name;
            transitionProgress = 0.0; // 开始过渡

            document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
        };

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            if (uniforms) uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
        }

        // --- 核心动画循环 ---
        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = (Date.now() - startTime) / 1000;
            uniforms.uTime.value = elapsedTime;

            // 音频分析
            let bass = 0, high = 0, avg = 0;
            if (analyser && isPlaying) {
                analyser.getByteFrequencyData(dataArray);
                // 计算低频 (Bass)
                for(let i=0; i<30; i++) bass += dataArray[i];
                bass = bass / 30 / 255; // 归一化 0.0 - 1.0

                // 计算高频 (Highs - 用于颤动)
                for(let i=100; i<200; i++) high += dataArray[i];
                high = high / 100 / 255;

                avg = (bass + high) / 2;
            } else {
                // 待机呼吸
                bass = 0.1 + Math.sin(elapsedTime) * 0.05;
                high = 0.05;
            }

            // 更新 Shader Uniforms
            // 使用指数平滑使音频反应更自然
            uniforms.uAudioLevel.value += (bass - uniforms.uAudioLevel.value) * 0.15;
            uniforms.uAudioHigh.value += (high - uniforms.uAudioHigh.value) * 0.1;
            uniforms.uMouse.value.copy(mouse);

            // 形状过渡进度
            if (transitionProgress < 1.0) {
                transitionProgress += 0.015; // 过渡速度
                if (transitionProgress > 1.0) transitionProgress = 1.0;
                uniforms.uTransitionProgress.value = transitionProgress;
            }

            controls.update(); // 更新轨道控制器
            composer.render();
        }
    </script>
</body>
</html>
