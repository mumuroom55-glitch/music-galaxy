<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Interstellar Fluid Breath</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #010103; font-family: 'Segoe UI', sans-serif; user-select: none; }
        
        /* 启动遮罩 */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            background: radial-gradient(circle, rgba(0,0,0,0.4) 0%, rgba(1,1,3,0.98) 100%);
            z-index: 10; flex-direction: column; transition: opacity 1.5s ease-out;
        }
        h1 { color: #fff; font-weight: 200; letter-spacing: 12px; text-shadow: 0 0 50px rgba(180,230,255,0.7); margin-bottom: 30px; opacity: 0.9; }
        
        /* 按钮风格：更极简、更轻盈 */
        label.upload-btn {
            background: rgba(255, 255, 255, 0.08); border: 1px solid rgba(255,255,255,0.2);
            color: #ccc; padding: 15px 50px; cursor: pointer; border-radius: 50px;
            font-size: 13px; letter-spacing: 3px; transition: 0.5s;
            backdrop-filter: blur(5px);
        }
        label.upload-btn:hover { background: rgba(255, 255, 255, 0.2); color: white; box-shadow: 0 0 40px rgba(100,200,255,0.3); }
        input[type="file"] { display: none; }

        /* 顶部形状切换栏 */
        #shape-controls {
            position: absolute; top: 30px; left: 50%; transform: translateX(-50%);
            z-index: 5; display: flex; gap: 15px;
            opacity: 0; transition: opacity 1.5s; pointer-events: none;
        }
        #shape-controls.visible { opacity: 1; pointer-events: auto; }
        
        .shape-btn {
            background: transparent; border: none; color: #666;
            padding: 8px 16px; cursor: pointer; font-size: 12px; transition: 0.5s; letter-spacing: 1px;
            position: relative;
        }
        .shape-btn::after {
            content: ''; position: absolute; bottom: 0; left: 50%; width: 0; height: 1px; 
            background: white; transition: 0.3s; transform: translateX(-50%);
        }
        .shape-btn:hover { color: #fff; }
        .shape-btn.active { color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.5); }
        .shape-btn.active::after { width: 60%; }

        /* 左下角播放器 */
        #player-ui {
            position: absolute; bottom: 40px; left: 40px; width: 320px;
            z-index: 5; display: flex; flex-direction: column; gap: 12px;
            opacity: 0; transition: opacity 1.5s; transform: translateY(20px);
        }
        #player-ui.visible { opacity: 1; transform: translateY(0); }

        .track-info { display: flex; justify-content: space-between; color: rgba(255,255,255,0.8); font-size: 11px; letter-spacing: 1px; }
        
        .controls-row { display: flex; align-items: center; gap: 20px; margin-top: 5px; }
        
        #play-pause-btn {
            width: 44px; height: 44px; border-radius: 50%; border: 1px solid rgba(255,255,255,0.15);
            background: rgba(255,255,255,0.03); color: #fff; cursor: pointer;
            display: flex; justify-content: center; align-items: center; font-size: 14px; transition: 0.4s;
            backdrop-filter: blur(4px);
        }
        #play-pause-btn:hover { background: rgba(255,255,255,0.15); border-color: rgba(255,255,255,0.4); }

        /* 细长的进度条 */
        input[type=range] {
            -webkit-appearance: none; width: 100%; background: transparent; cursor: pointer;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 2px; background: rgba(255,255,255,0.1);
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 10px; width: 10px; border-radius: 50%;
            background: #fff; margin-top: -4px; box-shadow: 0 0 10px rgba(255,255,255,0.5); opacity: 0; transition: 0.2s;
        }
        #player-ui:hover input[type=range]::-webkit-slider-thumb { opacity: 1; }
        
    </style>
</head>
<body>

    <div id="overlay">
        <h1>ETHEREAL FLOW</h1>
        <label class="upload-btn" for="musicUpload">Start Journey</label>
        <input type="file" id="musicUpload" accept="audio/*">
    </div>

    <div id="shape-controls">
        <button class="shape-btn active" onclick="switchShape('galaxy')">GALAXY</button>
        <button class="shape-btn" onclick="switchShape('sphere')">SPHERE</button>
        <button class="shape-btn" onclick="switchShape('heart')">HEART</button>
        <button class="shape-btn" onclick="switchShape('mobius')">MOBIUS</button>
        <button class="shape-btn" onclick="switchShape('mandala')">MANDALA</button>
    </div>

    <div id="player-ui">
        <div class="track-info">
            <span style="font-weight: 300;">FLUID SIMULATION</span>
            <span id="time-display" style="font-family: monospace; opacity: 0.6;">0:00</span>
        </div>
        <input type="range" id="progress-bar" value="0" step="0.1">
        <div class="controls-row">
            <button id="play-pause-btn">❚❚</button>
            <span style="font-size: 10px; color: rgba(255,255,255,0.3); letter-spacing: 1px;">RIPPLE ENGINE ON</span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <script>
        const PARTICLE_COUNT = 45000; 
        let camera, scene, renderer, composer;
        let particles, geometry;
        let analyser, dataArray, audioContext, audioEl;
        let currentShape = 'galaxy';
        let isPlaying = false;
        // 添加一个全局时间变量，用于计算波浪
        let time = 0; 
        
        const shapes = {};
        const targets = {
            sphere: [], galaxy: [], heart: [], mobius: [], mandala: []
        };
        const rand = (min, max) => Math.random() * (max - min) + min;

        const playBtn = document.getElementById('play-pause-btn');
        const progressBar = document.getElementById('progress-bar');
        const timeDisplay = document.getElementById('time-display');

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            // 极深的蓝黑色雾气
            scene.fog = new THREE.FogExp2(0x010103, 0.002);

            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 1, 5000);
            camera.position.z = 450;

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.3;
            document.body.appendChild(renderer.domElement);

            // 后期处理：更柔和的辉光
            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0; 
            bloomPass.strength = 1.8; 
            bloomPass.radius = 1.0; // 更大的半径，产生朦胧感

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            generateParticles();
            calculateShapes();

            window.addEventListener('resize', onWindowResize);
            document.getElementById('musicUpload').addEventListener('change', handleAudioUpload);
            
            playBtn.addEventListener('click', togglePlay);
            progressBar.addEventListener('input', () => {
                if(audioEl) audioEl.currentTime = (progressBar.value / 100) * audioEl.duration;
            });
        }

        function generateParticles() {
            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);
            const sizes = new Float32Array(PARTICLE_COUNT);

            const colorObj = new THREE.Color();

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                positions[i3] = rand(-1000, 1000);
                positions[i3+1] = rand(-1000, 1000);
                positions[i3+2] = rand(-1000, 1000);

                // 颜色更统一，使用类似极光的青蓝色系
                let hue = 0.55 + Math.random() * 0.15; // 0.55(Cyan) - 0.7(Purple)
                colorObj.setHSL(hue, 0.8, 0.7); 
                colors[i3] = colorObj.r;
                colors[i3+1] = colorObj.g;
                colors[i3+2] = colorObj.b;
                
                sizes[i] = rand(0.5, 2.5); 
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 2.0,
                vertexColors: true,
                map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png'),
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.8
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function calculateShapes() {
            // Galaxy - 优化螺旋，让它更平滑
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const angle = i * 0.05; // 紧密一些
                const r = i * 0.012;
                // 添加一些正态分布的随机性，而不是均匀随机，看起来更自然
                const randomOffset = () => (Math.random() + Math.random() + Math.random() - 1.5) * 15;
                
                targets.galaxy.push(
                    Math.cos(angle) * r * 10 + randomOffset(),
                    Math.sin(angle) * r * 10 + randomOffset(),
                    (Math.random()-0.5) * (120 - r) + randomOffset()
                );
            }
            // Sphere
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                const r = 200;
                targets.sphere.push(
                    r * Math.cos(theta) * Math.sin(phi),
                    r * Math.sin(theta) * Math.sin(phi),
                    r * Math.cos(phi)
                );
            }
            // Heart
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                 let t = rand(0, Math.PI * 2); 
                 let scale = 11;
                 let x = 16 * Math.pow(Math.sin(t), 3);
                 let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                 let z = rand(-5, 5) * (x * 0.1 + 4); // 稍微厚一点
                 targets.heart.push(x * scale, y * scale, z * scale);
            }
            // Mobius
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let u = rand(0, Math.PI * 2);
                let v = rand(-1, 1);
                let radius = 140;
                let width = 60;
                targets.mobius.push(
                    (radius + v * width/2 * Math.cos(u/2)) * Math.cos(u),
                    (radius + v * width/2 * Math.cos(u/2)) * Math.sin(u),
                    v * width/2 * Math.sin(u/2)
                );
            }
            // Mandala
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let r = rand(10, 220);
                let theta = rand(0, Math.PI * 2);
                let petals = 6; 
                let distortion = Math.sin(theta * petals) * 30;
                targets.mandala.push(
                    (r + distortion) * Math.cos(theta),
                    (r + distortion) * Math.sin(theta),
                    Math.sin(r * 0.1) * 20 + Math.sin(theta*10)*5
                );
            }
        }

        function handleAudioUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            if (audioEl) audioEl.pause();
            if (audioContext) audioContext.close();

            audioEl = document.createElement('audio');
            audioEl.src = URL.createObjectURL(file);
            audioEl.loop = false;
            
            audioEl.addEventListener('canplay', () => {
                if(!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const src = audioContext.createMediaElementSource(audioEl);
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 2048;
                    // 关键设置：使音频数据变化极其平滑
                    analyser.smoothingTimeConstant = 0.92; 
                    src.connect(analyser);
                    analyser.connect(audioContext.destination);
                    dataArray = new Uint8Array(analyser.frequencyBinCount);
                }
                playMusic();
            });

            audioEl.addEventListener('timeupdate', updateProgress);
            audioEl.addEventListener('ended', () => { isPlaying = false; playBtn.innerHTML = '►'; });

            document.getElementById('overlay').style.opacity = 0;
            setTimeout(() => {
                document.getElementById('overlay').style.display = 'none';
                document.getElementById('shape-controls').classList.add('visible');
                document.getElementById('player-ui').classList.add('visible');
            }, 1500);
        }

        function playMusic() {
            audioContext.resume().then(() => { audioEl.play(); isPlaying = true; playBtn.innerHTML = '❚❚'; });
        }
        function togglePlay() {
            if (!audioEl) return;
            if (isPlaying) { audioEl.pause(); playBtn.innerHTML = '►'; } 
            else { audioEl.play(); playBtn.innerHTML = '❚❚'; }
            isPlaying = !isPlaying;
        }
        function updateProgress() {
            if (audioEl && audioEl.duration) {
                progressBar.value = (audioEl.currentTime / audioEl.duration) * 100;
                timeDisplay.textContent = formatTime(audioEl.currentTime);
            }
        }
        function formatTime(s) {
            const m = Math.floor(s / 60);
            const sec = Math.floor(s % 60);
            return `${m}:${sec < 10 ? '0' : ''}${sec}`;
        }
        window.switchShape = function(name) {
            currentShape = name;
            document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
        };
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 核心动画逻辑 ---
        function animate() {
            requestAnimationFrame(animate);

            // 时间流逝
            time += 0.01;

            let bass = 0, mid = 0;
            let avgVolume = 0;

            if (analyser && isPlaying) {
                analyser.getByteFrequencyData(dataArray);
                let bSum = 0, mSum = 0;
                for(let i=0; i<40; i++) bSum += dataArray[i];
                for(let i=40; i<200; i++) mSum += dataArray[i];
                bass = bSum / 40;
                mid = mSum / 160;
                avgVolume = (bass * 2 + mid) / 3;
            } else {
                // 待机时的缓慢呼吸
                avgVolume = 20 + Math.sin(time * 0.5) * 10;
                bass = 20;
            }

            const positions = geometry.attributes.position.array;
            const targetPos = targets[currentShape];

            // 呼吸系数：使用正弦波叠加平滑后的音量
            // 让整个结构像肺部一样缓慢扩张和收缩
            const breath = (Math.sin(time * 0.8) * 0.02) + (avgVolume / 255) * 0.15; 
            const globalScale = 1 + breath;

            // 涟漪强度：随低音变化
            const rippleAmp = 2 + (bass / 255) * 15; 

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                // 1. 获取基础目标位置
                let tx = targetPos[i3];
                let ty = targetPos[i3+1];
                let tz = targetPos[i3+2];

                // 2. 计算距离中心的距离（用于波的传播）
                const dist = Math.sqrt(tx*tx + ty*ty + tz*tz);

                // 3. 计算涟漪波 (Ripple Wave)
                // sin(距离 * 频率 - 时间 * 速度)
                // 这就是物理中水波扩散的公式
                const wave = Math.sin(dist * 0.02 - time * 2);
                
                // 4. 将波应用到位置上
                // 我们沿着法线方向（从中心向外）推动粒子
                const directionX = tx / (dist || 1);
                const directionY = ty / (dist || 1);
                const directionZ = tz / (dist || 1);

                // 最终目标点 = (原点 + 呼吸缩放) + (波浪偏移)
                let destX = tx * globalScale + directionX * wave * rippleAmp;
                let destY = ty * globalScale + directionY * wave * rippleAmp;
                let destZ = tz * globalScale + directionZ * wave * rippleAmp;

                // 5. 平滑插值 (Lerp)
                // 降低速度系数 (0.03)，让运动像液体一样粘稠、平滑，而不是瞬移
                const smoothFactor = 0.03 + (mid/255) * 0.05;

                positions[i3] += (destX - positions[i3]) * smoothFactor;
                positions[i3+1] += (destY - positions[i3+1]) * smoothFactor;
                positions[i3+2] += (destZ - positions[i3+2]) * smoothFactor;
            }

            geometry.attributes.position.needsUpdate = true;
            
            // 缓慢旋转
            particles.rotation.y += 0.0008;
            particles.rotation.z = Math.sin(time * 0.2) * 0.05; // 轻微摆动

            // 辉光随呼吸明暗变化
            composer.passes[1].strength = 1.6 + (avgVolume / 255) * 0.8;

            composer.render();
        }
    </script>
</body>
</html>
