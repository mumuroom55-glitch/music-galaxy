<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Celestial Fluid Breath - Rhythmic & Colorful</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            background: radial-gradient(circle at center, #110022 0%, #000000 100%); /* 背景带点紫色调 */
            z-index: 10; flex-direction: column; transition: opacity 1.5s ease-out;
        }
        h1 { color: #fff; font-weight: 100; letter-spacing: 15px; text-shadow: 0 0 60px rgba(255,100,255,0.8), 0 0 20px rgba(100,200,255,0.4); margin-bottom: 40px; opacity: 0.95; font-size: 2.5em; text-align: center; }
        
        label.upload-btn {
            background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255,255,255,0.25);
            color: #fff; padding: 16px 60px; cursor: pointer; border-radius: 50px;
            font-size: 12px; letter-spacing: 4px; transition: 0.6s cubic-bezier(0.16, 1, 0.3, 1);
            backdrop-filter: blur(10px); text-transform: uppercase; box-shadow: 0 0 20px rgba(255,255,255,0.1);
        }
        label.upload-btn:hover { background: rgba(255, 255, 255, 0.25); box-shadow: 0 0 50px rgba(255,100,255,0.6), inset 0 0 20px rgba(255,255,255,0.2); transform: scale(1.05); }
        input[type="file"] { display: none; }

        #shape-controls {
            position: absolute; top: 40px; left: 50%; transform: translateX(-50%);
            z-index: 5; display: flex; gap: 25px;
            opacity: 0; transition: opacity 1.5s; pointer-events: none;
            background: rgba(0,0,0,0.5); padding: 10px 25px; border-radius: 30px;
            backdrop-filter: blur(8px); border: 1px solid rgba(255,255,255,0.1);
        }
        #shape-controls.visible { opacity: 1; pointer-events: auto; }
        
        .shape-btn {
            background: transparent; border: none; color: #999;
            padding: 8px 12px; cursor: pointer; font-size: 11px; transition: 0.4s; letter-spacing: 2px;
            position: relative; font-weight: 400;
        }
        .shape-btn::after {
            content: ''; position: absolute; bottom: 0; left: 50%; width: 0; height: 2px; 
            background: linear-gradient(90deg, transparent, #fff, transparent); transition: 0.4s cubic-bezier(0.16, 1, 0.3, 1); transform: translateX(-50%); opacity: 0;
        }
        .shape-btn:hover { color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.5); }
        .shape-btn.active { color: #fff; text-shadow: 0 0 20px rgba(255,200,255,0.8); }
        .shape-btn.active::after { width: 100%; opacity: 1; }

        #player-ui {
            position: absolute; bottom: 50px; left: 50px; width: 320px;
            z-index: 5; display: flex; flex-direction: column; gap: 15px;
            opacity: 0; transition: opacity 1.5s, transform 1.5s; transform: translateY(30px);
        }
        #player-ui.visible { opacity: 1; transform: translateY(0); }

        .track-info { display: flex; justify-content: space-between; color: rgba(255,255,255,0.8); font-size: 10px; letter-spacing: 2px; text-transform: uppercase; }
        
        .controls-row { display: flex; align-items: center; gap: 20px; margin-top: 5px; }
        
        #play-pause-btn {
            width: 44px; height: 44px; border-radius: 50%; border: 1px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.05); color: #fff; cursor: pointer;
            display: flex; justify-content: center; align-items: center; font-size: 14px; transition: 0.3s;
            backdrop-filter: blur(4px); box-shadow: 0 0 15px rgba(255,255,255,0.1);
        }
        #play-pause-btn:hover { background: rgba(255,255,255,0.2); border-color: rgba(255,255,255,0.5); box-shadow: 0 0 30px rgba(255,255,255,0.3); transform: scale(1.05); }

        input[type=range] {
            -webkit-appearance: none; width: 100%; background: transparent; cursor: pointer;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 2px; background: linear-gradient(90deg, rgba(255,255,255,0.1), rgba(255,255,255,0.5));
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 10px; width: 10px; border-radius: 50%;
            background: #fff; margin-top: -4px; box-shadow: 0 0 20px rgba(255,255,255,1); opacity: 0.8; transition: 0.3s;
        }
        input[type=range]:hover::-webkit-slider-thumb { opacity: 1; transform: scale(1.2); }
        
    </style>
</head>
<body>

    <div id="overlay">
        <h1>RHYTHMIC FLOW</h1>
        <label class="upload-btn" for="musicUpload">Ignite Journey</label>
        <input type="file" id="musicUpload" accept="audio/*">
    </div>

    <div id="shape-controls">
        <button class="shape-btn active" onclick="switchShape('galaxy', 0)">GALAXY</button>
        <button class="shape-btn" onclick="switchShape('heart', 1)">HEART CORE</button>
        <button class="shape-btn" onclick="switchShape('sphere', 2)">NEBULA ORB</button>
        <button class="shape-btn" onclick="switchShape('mobius', 3)">CYBER LOOP</button>
    </div>

    <div id="player-ui">
        <div class="track-info">
            <span style="font-weight: 400; opacity: 0.8; color: #bbf;">Audio Reactive Engine</span>
            <span id="time-display" style="font-family: monospace; opacity: 0.8;">0:00</span>
        </div>
        <input type="range" id="progress-bar" value="0" step="0.1">
        <div class="controls-row">
            <button id="play-pause-btn">❚❚</button>
            <span style="font-size: 9px; color: rgba(255,255,255,0.5); letter-spacing: 1px;">INTERACTIVE FIELD: ON</span>
        </div>
    </div>

    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float size;
        attribute vec3 customColor; // 初始随机颜色
        attribute vec3 targetPosition;

        uniform float uTime;
        uniform float uAudioLevel; // 经过指数增强的低音
        uniform float uAudioHigh;
        uniform vec2 uMouse;
        uniform vec2 uResolution;
        uniform float uTransitionProgress;
        
        varying vec3 vColor;
        varying float vDistance; // 传递距离中心的距离到片元着色器

        void main() {
            vColor = customColor;

            // 1. 基础形状插值
            vec3 mixedPos = mix(position, targetPosition, uTransitionProgress);
            float distFromCenter = length(mixedPos);
            vDistance = distFromCenter;

            // 2. 极具张力的节奏运动 (Rhythmic Expansion)
            // 基础缓慢呼吸
            float breathBase = sin(uTime * 0.5) * 0.03;
            
            // 关键修改：使用球面波 (Spherical Wave) 创造舒展感
            // 波随着距离向外传播
            float expansionWave = sin(uTime * 2.0 - distFromCenter * 0.005);
            
            // 音频驱动的巨大扩张力：音频越强，波峰推得越远
            // 系数 0.8 让幅度非常大
            float audioExpansion = expansionWave * uAudioLevel * 0.8;
            
            // 额外的“踢鼓”爆发力 (Kick)，让重音更脆
            float kick = pow(uAudioLevel, 2.0) * 0.3;

            // 高频颤动
            float tremble = sin(uTime * 15.0 + mixedPos.y * 0.05) * uAudioHigh * 0.03;
            
            // 总缩放比例
            float totalScale = 1.0 + breathBase + audioExpansion + kick + tremble;

            // 应用缩放
            vec3 finalPos = mixedPos * totalScale;

            // 3. 强力涟漪 (Ripple)
            float rippleWave = sin(distFromCenter * 0.02 - uTime * 4.0);
            vec3 rippleDir = normalize(finalPos);
            // 涟漪强度极大增加
            float rippleStrength = 5.0 + uAudioLevel * 80.0; 
            finalPos += rippleDir * rippleWave * rippleStrength;
            
            // 4. 鼠标排斥 (更灵敏)
            vec3 mouseWorldPos = vec3((uMouse.x * 2.0 - 1.0) * 450.0 * (uResolution.x/uResolution.y), (uMouse.y * 2.0 - 1.0) * 450.0, 0.0);
            float mouseDist = distance(finalPos.xy, mouseWorldPos.xy);
            float repulsionRadius = 200.0 + uAudioLevel * 100.0; // 排斥范围随音乐扩大
            
            if (mouseDist < repulsionRadius) {
                float force = (1.0 - mouseDist / repulsionRadius);
                force = pow(force, 3.0) * 180.0; // 力度更强
                vec2 dir = normalize(finalPos.xy - mouseWorldPos.xy);
                finalPos.xy += dir * force;
                finalPos.z -= force * 0.8;
            }

            vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
            
            // 粒子大小随音乐闪烁变大
            float beatFlashSize = 1.0 + uAudioLevel * 0.5;
            gl_PointSize = size * (500.0 / -mvPosition.z) * totalScale * beatFlashSize;
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform sampler2D pointTexture;
        uniform float uAudioLevel;
        uniform int uShapeIndex; // 0:Galaxy, 1:Heart, 2:Sphere, 3:Mobius

        varying vec3 vColor; // 初始随机颜色
        varying float vDistance;

        // 定义各模式的色板函数
        vec3 getGalaxyColor(float dist, float audio) {
            // 中心金/白 -> 中间蓝紫 -> 边缘深蓝
            vec3 core = vec3(1.0, 0.9, 0.5); // Gold
            vec3 mid = vec3(0.2, 0.4, 1.0);  // Blue
            vec3 edge = vec3(0.1, 0.0, 0.3); // Dark Purple
            float t = smoothstep(0.0, 500.0, dist);
            vec3 col = mix(core, mid, smoothstep(0.0, 200.0, dist));
            col = mix(col, edge, t);
            // 音频高潮时叠加青色闪光
            col += vec3(0.0, 0.8, 1.0) * audio * audio * 0.5;
            return col;
        }

        vec3 getHeartColor(float dist, float audio) {
            // 中心炽热白/黄 -> 中间红/橙 -> 边缘深红
            vec3 core = vec3(1.0, 1.0, 0.8); // Hot White
            vec3 mid = vec3(1.0, 0.2, 0.1);  // Red Orange
            vec3 edge = vec3(0.5, 0.0, 0.1); // Deep Red
            float t = smoothstep(0.0, 400.0, dist);
            vec3 col = mix(core, mid, smoothstep(0.0, 150.0, dist));
            col = mix(col, edge, t);
            // 音频高潮时叠加橙色闪光
            col += vec3(1.0, 0.5, 0.0) * audio * 0.6;
            return col;
        }

        vec3 getSphereColor(float dist, float audio) {
            // 极光色系：青 -> 绿 -> 蓝
            vec3 core = vec3(0.5, 1.0, 0.8); // Cyan/Greenish
            vec3 mid = vec3(0.0, 0.8, 1.0);  // Cyan Blue
            vec3 edge = vec3(0.0, 0.2, 0.6); // Ocean Blue
            float t = smoothstep(100.0, 350.0, dist);
            vec3 col = mix(core, mid, smoothstep(0.0, 200.0, dist));
            col = mix(col, edge, t);
            // 音频高潮时叠加白色闪光
            col += vec3(1.0) * audio * 0.4;
            return col;
        }

        vec3 getMobiusColor(float dist, float audio) {
            // 赛博朋克：品红 -> 青色 -> 紫色
            vec3 core = vec3(1.0, 0.0, 1.0); // Magenta
            vec3 mid = vec3(0.0, 1.0, 1.0);  // Cyan
            vec3 edge = vec3(0.4, 0.0, 0.8); // Purple
            // 使用 sin(dist) 创造环状条纹感
            float stripe = sin(dist * 0.05) * 0.5 + 0.5;
            vec3 col = mix(mid, core, stripe);
            col = mix(col, edge, smoothstep(150.0, 300.0, dist));
             // 音频高潮时叠加高亮
            col += vec3(0.8, 0.8, 1.0) * audio * 0.5;
            return col;
        }


        void main() {
            vec2 cxy = 2.0 * gl_PointCoord - 1.0;
            float r = dot(cxy, cxy);
            if (r > 1.0) discard;

            vec4 tex = texture2D(pointTexture, gl_PointCoord);
            
            vec3 themeColor;
            // 根据模式选择基础色板 (使用 if-else 选择，简单直接)
            if (uShapeIndex == 0) {
                themeColor = getGalaxyColor(vDistance, uAudioLevel);
            } else if (uShapeIndex == 1) {
                themeColor = getHeartColor(vDistance, uAudioLevel);
            } else if (uShapeIndex == 2) {
                themeColor = getSphereColor(vDistance, uAudioLevel);
            } else {
                themeColor = getMobiusColor(vDistance, uAudioLevel);
            }

            // 将初始随机颜色与主题颜色混合，保持一定的颗粒感多样性
            vec3 finalColor = mix(vColor, themeColor, 0.75);

            // 全局亮度增强，随音乐爆发
            finalColor *= (1.2 + uAudioLevel * 0.8); 
            
            // 边缘 Alpha 柔化
            float alpha = (1.0 - r) * (0.8 + uAudioLevel * 0.2);

            gl_FragColor = vec4(finalColor, alpha) * tex;
        }
    </script>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        const PARTICLE_COUNT = 100000; 
        
        let camera, scene, renderer, composer, controls;
        let particleSystem, uniforms, geometry;
        let analyser, dataArray, audioContext, audioEl;
        let currentShape = 'galaxy';
        let isPlaying = false;
        let startTime = Date.now();
        let mouse = new THREE.Vector2(0.5, 0.5);
        
        const shapes = { sphere: null, galaxy: null, heart: null, mobius: null };
        let transitionProgress = 1.0;

        // 用于平滑音频数据的变量
        let smoothedBass = 0;
        let smoothedHigh = 0;

        const rand = (min, max) => Math.random() * (max - min) + min;
        const randNormal = () => (Math.random() + Math.random() + Math.random() + Math.random() - 2.0) / 2.0;

        const playBtn = document.getElementById('play-pause-btn');
        const progressBar = document.getElementById('progress-bar');
        const timeDisplay = document.getElementById('time-display');

        init();
        calculateAllShapes();
        animate();

        function init() {
            scene = new THREE.Scene();
            // 背景雾气颜色调整为深紫/蓝
            scene.fog = new THREE.FogExp2(0x0a001a, 0.0012);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 5000);
            camera.position.set(0, 0, 600); // 相机拉远一点看大场面

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance", stencil: false, depth: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); 
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            // 提高曝光度，让画面更亮
            renderer.toneMappingExposure = 1.8; 
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.4;
            controls.enablePan = false;
            controls.maxDistance = 1500;
            controls.minDistance = 200;

            const renderScene = new THREE.RenderPass(scene, camera);
            // 增强 Bloom 效果
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 3.2, 0.7, 0.2);
            bloomPass.threshold = 0.1; 
            
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            createParticleSystem();

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousemove', onMouseMove);
            document.getElementById('musicUpload').addEventListener('change', handleAudioUpload);
            playBtn.addEventListener('click', togglePlay);
            progressBar.addEventListener('input', handleProgressInput);
        }

        function onMouseMove(event) {
            mouse.x = event.clientX / window.innerWidth;
            mouse.y = 1.0 - (event.clientY / window.innerHeight);
        }

        function createParticleSystem() {
            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);
            const sizes = new Float32Array(PARTICLE_COUNT);

            const colorObj = new THREE.Color();

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                positions[i3] = positions[i3+1] = positions[i3+2] = 0;
                targetPositions[i3] = targetPositions[i3+1] = targetPositions[i3+2] = 0;

                // 初始随机颜色 (作为底色在Shader中混合)
                // 使用更广泛的色相，确保每个模式混合后都有独特性
                let hue = Math.random();
                let saturation = rand(0.5, 1.0);
                let lightness = rand(0.4, 0.9);
                
                colorObj.setHSL(hue, saturation, lightness);
                colors[i3] = colorObj.r;
                colors[i3+1] = colorObj.g;
                colors[i3+2] = colorObj.b;

                // 基础大小差异化
                sizes[i] = rand(1.0, 4.0); 
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('targetPosition', new THREE.BufferAttribute(targetPositions, 3)); 
            geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            uniforms = {
                uTime: { value: 0.0 },
                uAudioLevel: { value: 0.0 }, 
                uAudioHigh: { value: 0.0 },  
                uMouse: { value: new THREE.Vector2(0.5, 0.5) },
                uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                uTransitionProgress: { value: 1.0 },
                uShapeIndex: { value: 0 }, // 新增：用于切换Shader中的颜色模式
                pointTexture: { value: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png') }
            };

            const material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true,
                vertexColors: true
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        function calculateAllShapes() {
             shapes.galaxy = new Float32Array(PARTICLE_COUNT * 3);
             const galaxy = shapes.galaxy;
             for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const radius = Math.pow(Math.random(), 1.8) * 400; // 稍微扩大范围
                const spinAngle = radius * 0.012;
                const branchAngle = (i % 6) * ((Math.PI * 2) / 6); // 6条旋臂
                const randomOffset = () => randNormal() * (25 + radius * 0.15);
                galaxy[i3] = Math.cos(branchAngle + spinAngle) * radius + randomOffset();
                galaxy[i3+1] = Math.sin(branchAngle + spinAngle) * radius + randomOffset();
                galaxy[i3+2] = randNormal() * (70 * (1 - radius/400) + 15) + randNormal() * 25; 
            }

            shapes.heart = new Float32Array(PARTICLE_COUNT * 3);
            const heart = shapes.heart;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                 const i3 = i * 3;
                 let t = rand(0, Math.PI * 2);
                 // 更立体的填充
                 let volumeScale = Math.pow(Math.random(), 0.4) * 14; 
                 let x = 16 * Math.pow(Math.sin(t), 3);
                 let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                 let z = randNormal() * 8; // 增加厚度
                 heart[i3] = x * volumeScale;
                 heart[i3+1] = y * volumeScale + 60; 
                 heart[i3+2] = z * volumeScale;
            }

            shapes.sphere = new Float32Array(PARTICLE_COUNT * 3);
            const sphere = shapes.sphere;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const radius = 250 * Math.pow(Math.random(), 0.3); // 更大的球体
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                sphere[i3] = radius * Math.sin(phi) * Math.cos(theta);
                sphere[i3+1] = radius * Math.sin(phi) * Math.sin(theta);
                sphere[i3+2] = radius * Math.cos(phi);
            }

             shapes.mobius = new Float32Array(PARTICLE_COUNT * 3);
             const mobius = shapes.mobius;
             for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                let u = rand(0, Math.PI * 2);
                let v = rand(-1, 1);
                let thickness = randNormal() * 20;
                let radius = 180;
                let stripWidth = 80;
                let x = (radius + v * stripWidth/2 * Math.cos(u/2)) * Math.cos(u);
                let y = (radius + v * stripWidth/2 * Math.cos(u/2)) * Math.sin(u);
                let z = v * stripWidth/2 * Math.sin(u/2) + thickness;
                mobius[i3] = x; mobius[i3+1] = y; mobius[i3+2] = z;
            }

            // 初始设置
            geometry.attributes.position.array.set(shapes[currentShape]);
            geometry.attributes.targetPosition.array.set(shapes[currentShape]);
            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.targetPosition.needsUpdate = true;
        }

        function handleAudioUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            if (audioEl) audioEl.pause();
            if (audioContext) audioContext.close();

            audioEl = document.createElement('audio');
            audioEl.src = URL.createObjectURL(file);
            audioEl.loop = false;
            
            audioEl.addEventListener('canplay', () => {
                if(!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const src = audioContext.createMediaElementSource(audioEl);
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 2048;
                    // 降低平滑常数，让反应更灵敏、更脆
                    analyser.smoothingTimeConstant = 0.75; 
                    src.connect(analyser);
                    analyser.connect(audioContext.destination);
                    dataArray = new Uint8Array(analyser.frequencyBinCount);
                }
                playMusic();
            });

            audioEl.addEventListener('timeupdate', updateProgress);
            audioEl.addEventListener('ended', () => { isPlaying = false; playBtn.innerHTML = '►'; });

            document.getElementById('overlay').style.opacity = 0;
            setTimeout(() => {
                document.getElementById('overlay').style.display = 'none';
                document.getElementById('shape-controls').classList.add('visible');
                document.getElementById('player-ui').classList.add('visible');
            }, 1500);
        }

        function playMusic() {
            audioContext.resume().then(() => { audioEl.play(); isPlaying = true; playBtn.innerHTML = '❚❚'; });
        }
        function togglePlay() {
            if (!audioEl) return;
            if (isPlaying) { audioEl.pause(); playBtn.innerHTML = '►'; } 
            else { audioEl.play(); playBtn.innerHTML = '❚❚'; }
            isPlaying = !isPlaying;
        }
        function updateProgress() {
            if (audioEl && audioEl.duration) {
                progressBar.value = (audioEl.currentTime / audioEl.duration) * 100;
                timeDisplay.textContent = formatTime(audioEl.currentTime);
            }
        }
        function handleProgressInput() {
             if(audioEl) audioEl.currentTime = (progressBar.value / 100) * audioEl.duration;
        }
        function formatTime(s) {
            const m = Math.floor(s / 60);
            const sec = Math.floor(s % 60);
            return `${m}:${sec < 10 ? '0' : ''}${sec}`;
        }
        
        // 更新切换函数，接收 index
        window.switchShape = function(name, index) {
            if (name === currentShape) return;
            
            geometry.attributes.position.array.set(geometry.attributes.targetPosition.array);
            geometry.attributes.targetPosition.array.set(shapes[name]);
            geometry.attributes.targetPosition.needsUpdate = true;

            currentShape = name;
            transitionProgress = 0.0; 
            
            // 更新 Shader 中的形状索引
            uniforms.uShapeIndex.value = index;

            document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
        };

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            if (uniforms) uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
        }

        // --- 核心动画循环 ---
        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = (Date.now() - startTime) / 1000;
            uniforms.uTime.value = elapsedTime;

            let bassRaw = 0, highRaw = 0;
            if (analyser && isPlaying) {
                analyser.getByteFrequencyData(dataArray);
                // 计算低频 (Bass) - 范围扩大一点
                for(let i=0; i<40; i++) bassRaw += dataArray[i];
                bassRaw = bassRaw / 40 / 255; 

                // 计算高频 (Highs)
                for(let i=100; i<220; i++) highRaw += dataArray[i];
                highRaw = highRaw / 120 / 255;
            } else {
                bassRaw = 0.15 + Math.sin(elapsedTime * 0.8) * 0.08;
                highRaw = 0.05;
            }

            // 对原始音频数据进行指数增强，使重音更突出
            let bassBoosted = Math.pow(bassRaw, 2.5); 

            // 在 JS 层进行轻微平滑，避免过于抖动，同时保持灵敏度
            smoothedBass += (bassBoosted - smoothedBass) * 0.25;
            smoothedHigh += (highRaw - smoothedHigh) * 0.2;

            uniforms.uAudioLevel.value = smoothedBass;
            uniforms.uAudioHigh.value = smoothedHigh;
            uniforms.uMouse.value.copy(mouse);

            if (transitionProgress < 1.0) {
                transitionProgress += 0.02; 
                if (transitionProgress > 1.0) transitionProgress = 1.0;
                uniforms.uTransitionProgress.value = transitionProgress;
            }

            controls.update(); 
            composer.render();
        }
    </script>
</body>
</html>
