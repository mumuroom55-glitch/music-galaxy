<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Ethereal Quantum Heart & Torch</title>
    <style>
        /* 背景更深邃，减少杂光 */
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Segoe UI', 'Helvetica Neue', sans-serif; user-select: none; }
        
        /* 启动遮罩 - 更加梦幻的渐变 */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            background: radial-gradient(circle at center, rgba(20,30,50,0.4) 0%, rgba(0,0,2,1) 80%);
            z-index: 10; flex-direction: column; transition: opacity 1.5s ease-out;
        }
        h1 { color: #fff; font-weight: 100; letter-spacing: 15px; font-size: 2.5em;
             text-shadow: 0 0 30px rgba(180,220,255,0.6), 0 0 60px rgba(180,220,255,0.3); margin-bottom: 40px; opacity: 0.95; }
        
        /* 极简主义按钮 */
        label.upload-btn {
            background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255,255,255,0.25);
            color: rgba(255,255,255,0.8); padding: 12px 40px; cursor: pointer; border-radius: 4px;
            font-size: 11px; letter-spacing: 4px; transition: all 0.6s cubic-bezier(0.16, 1, 0.3, 1);
            backdrop-filter: blur(10px); text-transform: uppercase;
        }
        label.upload-btn:hover { background: rgba(255, 255, 255, 0.25); color: white; box-shadow: 0 0 50px rgba(150,200,255,0.4); letter-spacing: 6px; }
        input[type="file"] { display: none; }

        /* 顶部形状切换栏 - 移除掉星系和混沌 */
        #shape-controls {
            position: absolute; top: 40px; left: 50%; transform: translateX(-50%);
            z-index: 5; display: flex; gap: 25px;
            opacity: 0; transition: opacity 2s; pointer-events: none;
        }
        #shape-controls.visible { opacity: 1; pointer-events: auto; }
        
        .shape-btn {
            background: transparent; border: none; color: rgba(255,255,255,0.4);
            padding: 5px 0; cursor: pointer; font-size: 10px; transition: 0.5s; letter-spacing: 2px;
            position: relative; text-transform: uppercase; font-weight: 300;
        }
        .shape-btn::after {
            content: ''; position: absolute; bottom: -5px; left: 50%; width: 0; height: 1px; 
            background: rgba(255,255,255,0.7); transition: 0.4s cubic-bezier(0.16, 1, 0.3, 1); transform: translateX(-50%);
        }
        .shape-btn:hover { color: rgba(255,255,255,0.8); }
        .shape-btn.active { color: #fff; text-shadow: 0 0 15px rgba(255,255,255,0.6); }
        .shape-btn.active::after { width: 100%; }

        /* 左下角播放器 - 更加隐形 */
        #player-ui {
            position: absolute; bottom: 50px; left: 50px; width: 280px;
            z-index: 5; display: flex; flex-direction: column; gap: 15px;
            opacity: 0; transition: opacity 2s 0.5s; transform: translateY(30px);
        }
        #player-ui.visible { opacity: 1; transform: translateY(0); }

        .track-info { display: flex; justify-content: space-between; color: rgba(255,255,255,0.6); font-size: 10px; letter-spacing: 1px; font-weight: 300;}
        
        .controls-row { display: flex; align-items: center; gap: 20px; margin-top: 5px; }
        
        #play-pause-btn {
            width: 36px; height: 36px; border-radius: 50%; border: 1px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.05); color: rgba(255,255,255,0.8); cursor: pointer;
            display: flex; justify-content: center; align-items: center; font-size: 12px; transition: 0.4s;
            backdrop-filter: blur(5px);
        }
        #play-pause-btn:hover { background: rgba(255,255,255,0.15); border-color: rgba(255,255,255,0.5); box-shadow: 0 0 20px rgba(255,255,255,0.2); }

        /* 极细进度条 */
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; cursor: pointer; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 1px; background: rgba(255,255,255,0.15); }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 8px; width: 8px; border-radius: 50%;
            background: #fff; margin-top: -3.5px; box-shadow: 0 0 15px rgba(255,255,255,0.8); opacity: 0.5; transition: 0.3s;
        }
        #player-ui:hover input[type=range]::-webkit-slider-thumb { opacity: 1; box-shadow: 0 0 20px rgba(255,255,255,1); }
        
    </style>
</head>
<body>

    <div id="overlay">
        <h1>ETHEREAL HEART & TORCH</h1>
        <label class="upload-btn" for="musicUpload">Begin Immersion</label>
        <input type="file" id="musicUpload" accept="audio/*">
    </div>

    <div id="shape-controls">
        <button class="shape-btn active" onclick="switchShape('heart')">HEART</button>
        <button class="shape-btn" onclick="switchShape('torch')">TORCH</button>
        <button class="shape-btn" onclick="switchShape('sphere')">SPHERE</button>
        <button class="shape-btn" onclick="switchShape('mobius')">MOBIUS</button>
        <button class="shape-btn" onclick="switchShape('mandala')">MANDALA</button>
    </div>

    <div id="player-ui">
        <div class="track-info">
            <span style="letter-spacing: 2px;">ARTISTIC VISUALIZER</span>
            <span id="time-display" style="font-family: monospace; opacity: 0.5;">0:00</span>
        </div>
        <input type="range" id="progress-bar" value="0" step="0.1">
        <div class="controls-row">
            <button id="play-pause-btn">❚❚</button>
            <span style="font-size: 9px; color: rgba(255,255,255,0.3); letter-spacing: 2px;">HDR BLOOM ENGINE</span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <script>
        // 增加粒子数量以获得更细腻的体积感
        const PARTICLE_COUNT = 55000; 
        let camera, scene, renderer, composer, bloomPass;
        let particles, geometry;
        let analyser, dataArray, audioContext, audioEl;
        let currentShape = 'heart'; // 默认心形
        let isPlaying = false;
        let time = 0; 
        
        const shapes = {};
        // 移除掉了 galaxy 和 lorenz
        const targets = { sphere: [], heart: [], mobius: [], mandala: [], torch: [] };
        // 存储每个粒子的基础色相，用于色彩变化
        const baseHues = new Float32Array(PARTICLE_COUNT);
        
        const rand = (min, max) => Math.random() * (max - min) + min;
        const playBtn = document.getElementById('play-pause-btn');
        const progressBar = document.getElementById('progress-bar');
        const timeDisplay = document.getElementById('time-display');

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            // 极深的纯黑雾气，增强对比度
            scene.fog = new THREE.FogExp2(0x000000, 0.0015);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 5000);
            camera.position.z = 500;

            // [关键设置] HDR渲染器配置
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance", stencil: false, depth: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            // 使用 ACESFilmicToneMapping 获得电影感
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            // 大幅提高曝光度，让亮部爆炸
            renderer.toneMappingExposure = 2.0; 
            document.body.appendChild(renderer.domElement);

            // [关键设置] 后期辉光参数调整
            const renderScene = new THREE.RenderPass(scene, camera);
            bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            // 阈值设为0，让所有粒子都参与辉光
            bloomPass.threshold = 0; 
            // 极高的强度，创造梦幻感
            bloomPass.strength = 3.5; 
            // 较大的半径，使光芒柔和漫射
            bloomPass.radius = 1.2; 

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            generateParticles();
            calculateShapes();

            window.addEventListener('resize', onWindowResize);
            document.getElementById('musicUpload').addEventListener('change', handleAudioUpload);
            
            playBtn.addEventListener('click', togglePlay);
            progressBar.addEventListener('input', () => {
                if(audioEl) audioEl.currentTime = (progressBar.value / 100) * audioEl.duration;
            });
        }

        function generateParticles() {
            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);
            const sizes = new Float32Array(PARTICLE_COUNT);

            const colorObj = new THREE.Color();

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                // 初始分布更广
                positions[i3] = rand(-1500, 1500);
                positions[i3+1] = rand(-1500, 1500);
                positions[i3+2] = rand(-1500, 1500);

                // [艺术感配色]
                // 创建一个更丰富的基底色盘：深蓝 -> 青色 -> 紫罗兰 -> 微金
                let hue;
                const mix = Math.random();
                if (mix < 0.4) hue = rand(0.55, 0.65); // 蓝-青
                else if (mix < 0.8) hue = rand(0.65, 0.75); // 蓝-紫
                else hue = rand(0.05, 0.12); // 微金/橙色点缀

                baseHues[i] = hue; // 记住这个基础色相

                // 初始亮度较低，等待音乐点亮
                colorObj.setHSL(hue, 0.9, 0.4); 
                colors[i3] = colorObj.r;
                colors[i3+1] = colorObj.g;
                colors[i3+2] = colorObj.b;
                
                // 粒子大小差异更大
                sizes[i] = rand(1.0, 4.0); 
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 3.0, // 基础大小增大
                vertexColors: true,
                // 使用中心极亮、边缘柔和的纹理
                map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png'),
                blending: THREE.AdditiveBlending, // 叠加模式是辉光的关键
                depthWrite: false,
                transparent: true,
                opacity: 1.0 // 不透明度拉满，提供最强的光源
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function calculateShapes() {
            // [新算法] 立体心形 (Volumetric Heart)
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                 let t = rand(0, Math.PI * 2);
                 let u = rand(0, Math.PI); // 用于3D球面分布
                 // 基础参数方程
                 let x = 16 * Math.pow(Math.sin(t), 3);
                 let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                 // 使用正弦函数创造自然的厚度变化，顶部厚底部薄
                 let zThickness = 4 + Math.sin(t)*3;
                 let z = (Math.random() - 0.5) * zThickness * Math.sin(u) * 4;

                 // [关键] 内部填充：通过随机缩放因子，将点分布在心形内部，而不仅仅是表面
                 // 使用 pow 让点更聚集在边界附近，形成体积感
                 let volumeScale = Math.pow(Math.random(), 0.3); 

                 let scale = 13; // 整体大小
                 targets.heart.push(
                     x * scale * volumeScale,
                     y * scale * volumeScale,
                     z * scale // Z轴已经包含了体积变化
                 );
            }

            // [新算法] 火炬 (Torch) - 基于提供的图片解析
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // 分为两部分，左右对称的扇形结构
                const side = i % 2 === 0 ? 1 : -1; 
                const t = rand(0, 1); // 垂直位置参数 (0-1)
                const u = rand(0, 1); // 水平位置参数 (0-1)

                // 火炬高度和宽度缩放
                const heightScale = 280;
                const widthScale = 100;
                const depthScale = 60;

                // 模拟火炬的曲线和褶皱
                // y轴: 从下到上，带有一定的曲线
                let y = (t - 0.5) * heightScale * 2;
                
                // x轴: 随着高度增加而展开，带有扇形的弯曲
                // 使用幂函数让底部更尖，顶部更宽
                let xBase = Math.pow(t, 1.2) * widthScale;
                // 添加水平方向的扇形褶皱
                let x = side * (xBase + Math.sin(u * Math.PI * 8) * 10 * t);

                // z轴: 模拟火炬的厚度和立体感
                // 随着高度增加，厚度增加，并带有波浪状的起伏
                let z = (Math.pow(t, 0.8) * depthScale * (u - 0.5) * 2) + Math.cos(u * Math.PI * 8) * 5 * t;

                // 整体向下平移，使其底部在中心附近
                y -= heightScale * 0.8;

                targets.torch.push(x, y, z);
            }

            // Sphere (更紧密)
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                const r = 220;
                targets.sphere.push(
                    r * Math.cos(theta) * Math.sin(phi),
                    r * Math.sin(theta) * Math.sin(phi),
                    r * Math.cos(phi)
                );
            }

            // Mobius
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let u = rand(0, Math.PI * 2);
                let v = rand(-1, 1);
                let radius = 160;
                let width = 70;
                targets.mobius.push(
                    (radius + v * width/2 * Math.cos(u/2)) * Math.cos(u),
                    (radius + v * width/2 * Math.cos(u/2)) * Math.sin(u),
                    v * width/2 * Math.sin(u/2)
                );
            }
            // Mandala
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let r = rand(10, 250);
                let theta = rand(0, Math.PI * 2);
                let petals = 8; 
                let distortion = Math.sin(theta * petals) * 40;
                targets.mandala.push(
                    (r + distortion) * Math.cos(theta),
                    (r + distortion) * Math.sin(theta),
                    Math.sin(r * 0.1) * 30 + Math.sin(theta*12)*10
                );
            }
        }

        function handleAudioUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            if (audioEl) audioEl.pause();
            if (audioContext) audioContext.close();

            audioEl = document.createElement('audio');
            audioEl.src = URL.createObjectURL(file);
            audioEl.loop = false;
            
            audioEl.addEventListener('canplay', () => {
                if(!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const src = audioContext.createMediaElementSource(audioEl);
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 4096; // 更高精度
                    // 保持平滑，但比之前稍微灵敏一点点，为了捕捉爆发
                    analyser.smoothingTimeConstant = 0.9; 
                    src.connect(analyser);
                    analyser.connect(audioContext.destination);
                    dataArray = new Uint8Array(analyser.frequencyBinCount);
                }
                playMusic();
            });

            audioEl.addEventListener('timeupdate', updateProgress);
            audioEl.addEventListener('ended', () => { isPlaying = false; playBtn.innerHTML = '►'; });

            document.getElementById('overlay').style.opacity = 0;
            setTimeout(() => {
                document.getElementById('overlay').style.display = 'none';
                document.getElementById('shape-controls').classList.add('visible');
                document.getElementById('player-ui').classList.add('visible');
            }, 1500);
        }

        function playMusic() { audioContext.resume().then(() => { audioEl.play(); isPlaying = true; playBtn.innerHTML = '❚❚'; }); }
        function togglePlay() {
            if (!audioEl) return;
            if (isPlaying) { audioEl.pause(); playBtn.innerHTML = '►'; } 
            else { audioEl.play(); playBtn.innerHTML = '❚❚'; }
            isPlaying = !isPlaying;
        }
        function updateProgress() { if (audioEl && audioEl.duration) { progressBar.value = (audioEl.currentTime / audioEl.duration) * 100; timeDisplay.textContent = formatTime(audioEl.currentTime); }}
        function formatTime(s) { const m = Math.floor(s / 60); const sec = Math.floor(s % 60); return `${m}:${sec < 10 ? '0' : ''}${sec}`; }
        window.switchShape = function(name) {
            currentShape = name;
            document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
        };
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 核心动画逻辑 (艺术感与动力学) ---
        function animate() {
            requestAnimationFrame(animate);
            time += 0.008; // 时间流逝稍慢

            let bass = 0, high = 0, avgVolume = 0;

            if (analyser && isPlaying) {
                analyser.getByteFrequencyData(dataArray);
                let bSum = 0, hSum = 0;
                for(let i=2; i<60; i++) bSum += dataArray[i]; // 聚焦超低频
                for(let i=300; i<1000; i++) hSum += dataArray[i]; // 高频
                bass = bSum / 58;
                high = hSum / 700;
                avgVolume = (bass * 3 + high) / 4; // 低音主导
            } else {
                // 待机时极其微弱的呼吸
                avgVolume = 5 + Math.sin(time * 0.5) * 5;
            }

            const positions = geometry.attributes.position.array;
            const colors = geometry.attributes.color.array;
            const targetPos = targets[currentShape];
            const colorObj = new THREE.Color();

            // [关键动力学：轻重缓急]
            // 使用指数函数 (pow 2.8) 来创造非线性响应。
            // 音量小的时候，值极小；音量大时，值指数级爆发。
            const dynamicBreath = Math.pow(avgVolume / 255, 2.8) * 0.6;
            
            // 基础缓慢呼吸波
            let baseBreathWave = Math.sin(time * 0.7) * 0.03;

            // [心形专属律动]
            if (currentShape === 'heart') {
                // 叠加一个模拟心跳的快速双重脉冲
                let heartbeat = Math.pow(Math.sin(time * 3), 10) * 0.05 + Math.pow(Math.sin(time * 3 + 0.4), 10) * 0.03;
                baseBreathWave += heartbeat;
            }
            
            const globalScale = 1 + baseBreathWave + dynamicBreath;

            // 涟漪强度同样是非线性的
            const rippleAmp = Math.pow(bass / 255, 3) * 25; 

            // [HDR 色彩强度]
            // 基础亮度 + 音乐带来的爆发亮度。高潮时亮度值可以轻松超过 5.0
            let hdrStrength = 0.8 + Math.pow(avgVolume/255, 2) * 4.0;
            // 高频声音带来额外的白色闪光
            let flash = Math.pow(high/255, 4) * 3.0;

            // [火炬专属律动参数]
            let torchFlicker = 0;
            if (currentShape === 'torch') {
                // 模拟火焰的闪烁和向上跳动
                // 使用低音和高音的组合来控制跳动幅度
                torchFlicker = (Math.pow(bass / 255, 2) * 0.1 + Math.pow(high / 255, 2) * 0.05) * (Math.random() * 0.5 + 0.5);
            }

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                let tx = targetPos[i3];
                let ty = targetPos[i3+1];
                let tz = targetPos[i3+2];

                const dist = Math.sqrt(tx*tx + ty*ty + tz*tz);
                // 波浪速度随音乐能量加快
                const waveSpeed = time * (2 + dynamicBreath*3);
                const wave = Math.sin(dist * 0.015 - waveSpeed);
                
                const dirX = tx / (dist || 1);
                const dirY = ty / (dist || 1);
                const dirZ = tz / (dist || 1);

                let destX, destY, destZ;

                if (currentShape === 'torch') {
                    // [火炬专属动力学]
                    // 向上跳动：y轴方向添加基于音乐的偏移，越高跳动越明显
                    const flickerY = torchFlicker * (ty + 300) * 0.02 * Math.random();
                    // 水平抖动：x和z轴方向添加轻微的随机抖动
                    const flickerXZ = torchFlicker * 5 * (Math.random() - 0.5);
                    
                    destX = tx + flickerXZ;
                    destY = ty + flickerY;
                    destZ = tz + flickerXZ;
                } else {
                    // 其他形状的通用涟漪动力学
                    destX = tx * globalScale + dirX * wave * rippleAmp;
                    destY = ty * globalScale + dirY * wave * rippleAmp;
                    destZ = tz * globalScale + dirZ * wave * rippleAmp;
                }

                // 极度平滑的插值
                const smoothFactor = 0.025 + Math.pow(avgVolume/255, 3) * 0.08;
                positions[i3] += (destX - positions[i3]) * smoothFactor;
                positions[i3+1] += (destY - positions[i3+1]) * smoothFactor;
                positions[i3+2] += (destZ - positions[i3+2]) * smoothFactor;

                // [艺术感 HDR 色彩更新]
                let hue, saturation, lightness;

                if (currentShape === 'torch') {
                    // [火炬专属配色]：红、粉、橙
                    // 根据高度（y轴）混合颜色，底部偏红橙，顶部偏粉白
                    const normalizedY = (ty + 300) / 600; // 将y坐标归一化到0-1
                    // 红色(0.0) -> 橙色(0.08) -> 粉色(0.9)
                    hue = normalizedY * 0.1 + (Math.random() > 0.8 ? 0.9 : 0.0);
                    // 音乐越强，饱和度越低（越接近白光）
                    saturation = 0.9 - flash * 0.3;
                    // 音乐越强，亮度越高，且顶部更亮
                    lightness = 0.5 + normalizedY * 0.3 + hdrStrength * 0.2 + flash * 0.2;
                } else {
                    // 其他形状的通用配色
                    hue = baseHues[i];
                    saturation = 0.9 - flash * 0.2;
                    lightness = 0.4 + hdrStrength * 0.15 + flash * 0.1;
                }

                colorObj.setHSL(hue, saturation, lightness);

                // [关键] 将颜色值乘以 HDR 强度，使其突破 1.0，产生辉光
                // 火炬模式下辉光强度稍作调整
                const finalStrength = currentShape === 'torch' ? hdrStrength * 1.2 + flash : hdrStrength + flash;
                colors[i3] = colorObj.r * finalStrength;
                colors[i3+1] = colorObj.g * finalStrength;
                colors[i3+2] = colorObj.b * finalStrength;
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            
            particles.rotation.y += 0.0005 + dynamicBreath * 0.002;
            // 辉光强度也随音乐动态爆发
            bloomPass.strength = 3.5 + Math.pow(avgVolume/255, 3) * 3.0;

            composer.render();
        }
    </script>
</body>
</html>